# Node

- 実装コード
  - [node.go](../../../internal/storage/access/btree/node/node.go)
  - [leaf_node.go](../../../internal/storage/access/btree/node/leaf_node.go)
  - [branch_node.go](../../../internal/storage/access/btree/node/branch_node.go)

## ノード構造

- すべてのノードは、先頭に 8 バイトのノードタイプヘッダーを持つ
  - ノードタイプヘッダー: 8 バイト
    - `"LEAF    "` (リーフノード) または `"BRANCH  "` (ブランチノード)
    - ページデータの先頭 8 バイトを読み取ることで、ノード型を判定できる

## key-value ペア

- ノードは key-value ペアを格納する。
- ペアのバイト列は以下のように構成される

  ```txt
  |key サイズ  |key (可変長)      |value (可変長)      |
  ↑__4 bytes__↑__keySize bytes__↑__valueSize bytes__↑
  ```

## リーフノード

- 構造

  ```txt
  |ノードタイプ |リーフノードヘッダー|Slotted Page  |
  ↑__8 bytes__↑____16 bytes____↑__4072 bytes__↑
  ```

  - 合計 4096 byte (1 ページのサイズ)
  - ノードタイプ: 8 byte (`"LEAF    "`)
  - リーフノードヘッダー: 16 byte (前ページ ID + 次ページ ID)
  - Slotted Page: 4072 byte

- リーフノードのデータ構造は Slotted Page になっているので、データの挿入などは [Slotted Page](./slotted-page.md) の仕様に従う
- Slotted Page のスロット数 = key-value ペアの数

### リーフノードヘッダーの構成

- サイズ: 16 byte
  - 前のページへのポインタ (ページ ID): 8 byte (ノードタイプの次の 8 byte)
    - 前のリーフノードのページ ID を格納する
  - 次のページへのポインタ (ページ ID): 8 byte (前のページへのポインタの次の 8 byte)
    - 次のリーフノードのページ ID を格納する

つまり前のページへのポインタを読み取る際には、ページデータの 8 byte 目から 8 byte を読み取れば良い。(同様に次のページへのポインタは 16 byte 目から 8 byte を読み取れば良い)

書き込みの際も同様に、8 byte 目から 8 byte に前のページ ID を、16 byte 目から 8 byte に次のページ ID を書き込めば良い。

### リーフノードの分割

#### 1. 新しいリーフノードを作成する

#### 2. ループ処理の開始

1. 新規挿入対象の key が、自身のリーフノードの先頭の key よりも大きい場合
   - 新しいリーフノードの末尾に、自身のリーフノードの先頭の key-value ペアを移動
   - これを、新しいリーフノードが半分埋まるまで繰り返す

2. 新規挿入対象の key が、自身のリーフノードの先頭の key 以下の場合
   - 新しいリーフノードの末尾に、新規挿入対象の key-value ペアを挿入

3. 新しいリーフノードが半分埋まった場合
   - 自身のリーフノードに新規ペアを挿入して、ループ終了

_以下例_

```txt
初期状態: self = [1, 3, 5, 7, 9] (満杯)
新しいペア: newPair.Key = 4

ループ1回目:

- この時点では、新しいリーフノードは空の状態 (半分埋まってない)
- 新規挿入対象の key (4) が、自身のリーフノードの先頭の key (1) よりも大きい
  -> 自身の先頭の key-value ペアを、新しいリーフノードの末尾に移動させる
  -> self = [3, 5, 7, 9], new = [1]

ループ2回目:
  - この時点でも、新しいリーフノードは半分埋まってない
  - 新規挿入対象の key (4) が、自身のリーフノードの先頭の key (3) よりも大きい
    -> 自身の先頭の key-value ペアを、新しいリーフノードの末尾に移動させる
    -> self = [5, 7, 9], new = [1, 3]

ループ3回目:
  - この時点でも、新しいリーフノードは半分埋まってない
  - 新規挿入対象の key (4) が、自身のリーフノードの先頭の key (5) 以下
  -> 新しいリーフノードの末尾に新規挿入対象のペアを挿入する
  -> self = [5, 7, 9], new = [1, 3, 4]
  -> 半分埋まったので終了
```

## ブランチノード

- 構造

  ```txt
  |ノードタイプ |ブランチノードヘッダー|Slotted Page  |
  ↑__8 bytes__↑______8 bytes______↑__4080 bytes__↑
  ```

  - 合計 4096 byte (1 ページのサイズ)
  - ノードタイプ: 8 byte (`"BRANCH  "`)
  - ブランチノードヘッダー: 8 byte (右子ページ ID)
  - Slotted Page: 4080 byte

- ブランチノードのデータ構造は Slotted Page になっているので、データの挿入などは [Slotted Page](./slotted-page.md) の仕様に従う
- Slotted Page のスロット数 = key-value ペアの数

### ブランチノードヘッダーの構成

- サイズ: 8 byte
  - 右の子ノードへのポインタ (ページ ID): 8 byte (ノードタイプの次の 8 byte)
    - ブランチノードの右の子ノードのページ ID を格納する (以下例)

#### 右の子ノードのページ ID を格納する理由

- 前提として、 B+Tree のブランチノードでは、n 個のキーに対して n+1 個の子ノードのポインタが必要
- Slotted Page に n 個のペア (key, childPageId) を格納すると、n 個の子ポインタしか格納できない
  - そのため残りの 1 個 (右端の子ポインタ) をヘッダーに格納する

_以下例_

```txt
ブランチノード:
┌─────────────────────────────────────┐
│ Header: RightChildPageId = 30       │
├─────────────────────────────────────┤
│ Pair 0: (key=50,  value=10)         │
│ Pair 1: (key=100, value=20)         │
└─────────────────────────────────────┘

木構造:
            [Branch: 50, 100]
            /       |         \
          10       20          30
        (<50)   (50-99)      (>=100)
          /         |              \
[Leaf:10,20,30] [Leaf:60,70] [Leaf:110,120]
(PageID=10)     (PageID=20)   (PageID=30)
```

### ブランチノードの分割

[リーフノードの分割](#リーフノードの分割) と同様の手順で分割
