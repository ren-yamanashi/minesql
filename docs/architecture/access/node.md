# Node

- 実装コード
  - [node.go](../../../internal/storage/access/btree/node/node.go)
  - [leaf_node.go](../../../internal/storage/access/btree/node/leaf_node.go)
  - [internal_node.go](../../../internal/storage/access/btree/node/internal_node.go)

## key-value ペア

- ノードは key-value ペアを格納する。
- ペアのバイト列は以下のように構成される

  ```txt
  |key サイズ  |key (可変長)      |value (可変長)      |
  ↑__4 bytes__↑__keySize bytes__↑__valueSize bytes__↑
  ```

## ブランチノード

## リーフノード

- 構造

  ```txt
  |リーフヘッダー |Slotted Page  |
  ↑__16 bytes__↑__4080 bytes__↑
  ```

  - 合計 4096 byte (1 ページのサイズ)

- リーフノードのデータ構造は Slotted Page になっているので、データの挿入などは [Slotted Page](./slotted-page.md) の仕様に従う
- Slotted Page のスロット数 = key-value ペアの数

### ヘッダーの構成

- サイズ: 16 byte
  - 前のページへのポインタ (ページ ID): 8 byte (先頭から 8 byte)
    - 前のリーフノードのページ ID を格納する
  - 次のページへのポインタ (ページ ID): 8 byte (前のページへのポインタの次の 8 byte)
    - 次のリーフノードのページ ID を格納する

つまり前のページへのポインタを読み取る際には、Node のデータの先頭から 8 byte を読み取れば良い。(同様に次のページへのポインタもその次の 8 byte を読み取れば良い)

書き込みの際も同様に、先頭から 8 byte に前のページ ID を、その次の 8 byte に次のページ ID を書き込めば良い。

### リーフノードの分割

#### 1. 新しいリーフノードを作成する

#### 2. ループ処理の開始

1. 新規挿入対象の key が、自身のリーフノードの先頭の key よりも大きい場合
   - 新しいリーフノードの末尾に、自身のリーフノードの先頭の key-value ペアを移動
   - これを、新しいリーフノードが半分埋まるまで繰り返す

2. 新規挿入対象の key が、自身のリーフノードの先頭の key 以下の場合
   - 新しいリーフノードの末尾に、新規挿入対象の key-value ペアを挿入

3. 新しいリーフノードが半分埋まった場合
   - 自身のリーフノードに新規ペアを挿入して、ループ終了

_以下例_

```txt
初期状態: self = [1, 3, 5, 7, 9] (満杯)
新しいペア: newPair.Key = 4

ループ1回目:

- この時点では、新しいリーフノードは空の状態 (半分埋まってない)
- 新規挿入対象の key (4) が、自身のリーフノードの先頭の key (1) よりも大きい
  -> 自身の先頭の key-value ペアを、新しいリーフノードの末尾に移動させる
  -> self = [3, 5, 7, 9], new = [1]

ループ2回目:
  - この時点でも、新しいリーフノードは半分埋まってない
  - 新規挿入対象の key (4) が、自身のリーフノードの先頭の key (3) よりも大きい
    -> 自身の先頭の key-value ペアを、新しいリーフノードの末尾に移動させる
    -> self = [5, 7, 9], new = [1, 3]

ループ3回目:
  - この時点でも、新しいリーフノードは半分埋まってない
  - 新規挿入対象の key (4) が、自身のリーフノードの先頭の key (5) 以下
  -> 新しいリーフノードの末尾に新規挿入対象のペアを挿入する
  -> self = [5, 7, 9], new = [1, 3, 4]
  -> 半分埋まったので終了
```
